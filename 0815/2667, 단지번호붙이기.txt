#while문 입력(BFS)
from collections import deque

m, n = map(int,input().split()) #행, 열 받기
while m!=0 and n!=0:
	visited = [[0 for _ in range(m)] for _ in range(n)]  #방문 횟수
	graph = [[0 for _ in range(m)] for _ in range(n)]   #그래프 작성
	dr = [-1,-1,-1,0,0,1,1,1]
	dc = [-1,0,1,-1,1,-1,0,1]
	
	#r-1,c-1	 r-1,c	r-1,c+1
	#r,c-1	 r,c	r,c+1
	#r+1,c-1	 r+1,c	r+1,c+1
	
	for i in range(n):  #입력받을 그래프 열
	    li = list(map(int, input().split()))    #그래프 행에 입력할 수 띄어쓰기로 받음
	    for j in range(len(li)):    #입력받은 수 만큼 열 만들기
	        graph[i][j] = li[j]     #입력받은 값 열에 부여
	        #print(graph[i][j], end=' ')
	
	#def printf():      #visited가 돌아가는걸 확인하는 코드
	#    for i in range(n):
	#        for j in range(m):
	#           print(visited[i][j], end=' ')
	#            print()
	#        print()
	
	def DFS():
	    for i in range(1, n+1):
	        if graph[x][i] == 1 and visited[i]==0:
	            visited[i] == 1
	            DFS(i)
	
	
	def BFS(i,j):
	    q = deque()
	    q.append([i,j])
	    while len(q) != 0:
	        now = q.popleft()
	        r = now[0]
	        c = now[1]
	        for i in range(8):
	            nr = r+dr[i]
	            nc = c+dc[i]
	            if nr>=0 and nr<n and nc>=0 and nc<m:
	                if graph[nr][nc] == 1 and visited[nr][nc] == 0:
	                    visited[nr][nc]=1
	                    q.append([nr,nc])
	                    
	ans = 0
	for i in range(n):
	    for j in range(m):
	        if graph[i][j]==1 and visited[i][j]==0:
	            #printf()
	            visited[i][j] = 1
	            BFS(i,j)
	            ans += 1
	            #printf()
	print(ans)
	m, n = map(int,input().split()) #행, 열 받기


####################################
"""
from collections import deque
n = int(input())
graph = [[0 for _ in range(n)] for _ in range(n)]
visited = [[0 for _ in range(n)] for _ in range(n)]
dr = [1,-1,0,0]
dc = [0,0,1,-1]

ans=[]
sum1=0

def BFS(i,j):
    global sum1
    q = deque()
    q.append([i,j])
    while len(q)!=0:
        now=q.popleft()
        r=now[0]
        c=now[1]
        for i in range(4):
            nr = r+dr[i]
            nc = c+dc[i]
            if nr>=0 and nr<n and 0<=nc and nc<n:
                if graph[nr][nc] == 1 and visited[nr][nc]==0:
                    visited[nr][nc]=1
                    sum1+=1
                    q.append([nr,nc])

for i in range(n):
    str = input()
    for j in range(len(str)):
        graph[i][j]=int(str[j])
        
for i in range(n):
    for j in range(n):
        if graph[i][j] == 1 and visited[i][j]==0:
            sum1=1
            visited[i][j]=1
            BFS(i,j)
            ans.append(sum1)
ans.sort()
print(len(ans))
for x in ans:
    print(x)
"""