7. 3.
7-4
시간 초과
 -> sys.stdin.readline()을 쓰지 않고 input()을 쓰면 시간초과 난다

변수 하나에 split()으로 입력하면 알아서 리스트처럼 값을 받으므로 굳이 리스트를 선언할 필요 없다.
-------------------------
7-5
(가 오면 막대기가 시작된다는건 알았지만,
)가 왔을때 상황별로 어떻게 계산해야 되는지는 몰랐다
 -> 1. ) 앞에 (가 있으면 스택의 길이만큼(입력이 아니고 마지막 '('는 제외한) 더해준다
     2. (가 앞에 없는 )는 그냥 총 개수에 1을 더한다
-------------------------
7-6
계산식 자체를 생각하지 못햇다
인덱스 위치값보다 현재 인덱스-1 위치값이 작고 지울 수 있는 횟수가 남아있다면 현재인덱스-1 위치값을 지워준다

while문을 나왔을때 순회중인 cnt 건드리지 않고 num을 넣어줘야 그 다음 수가 자기 바로 앞수와 계산할 수 있다
ex) 1924에서 2는 9보다 작아서 while에서는 들어가지 않지만, 반복문 종료 후 answer에 들어가야 그 다음 수인 4와 비교할 수 있다
즉, 앞 수 보다 크던 작던 answer에는 들어가지만, 그 다음턴에 뒤의 수보다 작다면 answer에서 빠지고 cnt를 카운트한다

똑같이 출력되는거 같은데 print(''.join(answer[:N-K]))를 해야 맞는다
print(''.join(answer))는 틀렸다고 한다
어차피 answer에 들어간 수가 N개의 리스트에서 K개의 수를 뺀 값일텐데....

========================================

7. 4.
7-4
맞춤
그런데 함수를 이용해서 출력하는게 익숙하지 않다
-------------------------
7-5
answer.pop()으로 계산을 위해 쌓아놓은 스택에서 빼는걸 생각하지 못했다
하지만 자력으로 풀어서 맞춤
-------------------------
7-6
number = list(input())
print(''.join(answer[:N-K]))
를 틀림
정신없다보니 헷갈린거 같다

========================================

7. 5.
7-4
맞춤
드디어 제대로 함수를 이용해서 문제를 풀었다
-------------------------
7-5
맞춤
다만 어느 리스트에 값을 입력하고
어느 리스트가 괄호를 계산하는데 쓰이는지 생각하지 못했다
-------------------------
7-6
result[:N-K] 깜빡했다

========================================

7. 6.
7-4
맞춤
for문 안에서만 sys.stdin.readline()을 써도 시간초과 나지 않는다
-------------------------
7-5
맞춤
기억이 잘 안났다
그래도 ()인 경우와 )인 경우의 합을 기억해서 맞출 수 있었다
-------------------------
7-6
맞춤
그런데 풀기 전에 실수노트 정리하느라 N-K를 봐버렸다
문제 풀때 자료형 확인 잘 할것