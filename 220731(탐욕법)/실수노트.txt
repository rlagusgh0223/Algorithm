7.31.
12-2
맞추긴 했는데
now를 어차피 만들었고, 다른 조건에서도 동일하게 쓰이니까
조건문 위에서 만들고 같이 쓰면 되는걸 생각하지 못했다.
------------------
12-3
람다식과 종료시간과 시작시간을 비교해보는 반복문을 생각하지 못했다.
시간도 너무 오래 걸린다.
예전에 했던것과 차이는 sys.stdin.readline()으로 받은것뿐인것 같은데 내일 한번 비교해보겠다.
------------------
12-4
아직 뭐가 뭔지는 모르겠다
------------------
12-5
지속적인 공부 필요
일단 코드는 외웠다
-------------------
12-6
모범답안이 틀렸다고 나온다
앞으로 이 문제는 보지 않겠다

===========================

8. 1.
12-2
맞춤
------------------
12-3
맞춤
컴퓨터에 문제가 있는것 같다
똑같은 코드인데 오늘건 안되고 어제건 된다
같은 코드지만 복사해서 붙여넣었는데 잘 돌아가는걸 확인했다.
------------------
12-4
지속적인 반복 필요
------------------
12-5
반복학습해야된다

===========================

8. 2.
12-2
sys.stidin.readline()으로 받으면 마지막에 \n도 입력되지만,
계산하기 전에 int로 변환해서 문제 없는 것 같다
메모리는 input()과 똑같고, 시간은 약간 더 늦었다
---------------------
12-3
sys.stdin.readline()으로 했더니 시간이 확 줄었다
메모리는 차이 없다
---------------------
12-4
j부분 반복문을 잘못 생각했다
지속적인 반복 필요
sys.stdin.readline()으로 했는데 크게 시간이 달라지진 않았다
메모리는 그대로다
--------------------
12-5
j부분 반복문을 헷갈렸고
if-else구문을 잘못 기억하고 있었다.
지속적인 반복 필요
sys.stdin.readline()으로 했는데 시간과 메모리 차이없다

===========================

8. 3.
12-2
새로운 방식으로 해봤는데 틀렸다고 한다.
그런데 왜 틀린건지 모르겠다.
예제의 답은 잘 나온다
-------------------------
12-3
맞춤
-------------------------
12-4
지속적인 반복 필요
-------------------------
12-5
반복을 1000까지만 하도록 입력해서
csort를 1001로 선언해봤더니 런타임 에러 뜬다
숫자를 맞추려고 1000보다 많이 값을 준거라고 생각했는데
지금보니 중간에 csort[i+2]때문에 1002로 한거 같다.

===========================

8. 4.
12-2
저번처럼 되는 코드인데 이유없이 안되는 건가 해서 다시 도전해봤다.
그런데 여전히 틀렸다고 한다.
그냥 순서로 들어오는 경우와 아예 입력을 하는 경우의 차이 같은데
type도 같고, 결과도 같은데 왜 하나는 맞고 하나는 틀리는 건지 모르겠다.
--------------------
12-3
똑같은 코드인데 어쩔땐 뜬금없는 값이 나온다.
이유를 모르겠다.
--------------------
12-4
오늘은 idx != i인경우를 생각하지 못했다.
-------------------
12-5
반복 필요